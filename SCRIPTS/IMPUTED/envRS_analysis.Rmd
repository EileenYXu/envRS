---
title: "envRS in ABCD"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

```{r setup}
knitr::opts_chunk$set(warning = F, message = F)

library(tidyverse)
```

```{r eval=F}
#for the love of god why didn't i save a copy of the nicely renamed columns
base_train = readRDS("G://users/eileen/ABCD/ABCD_Environmental_Risk/ABCDv5.1/DATA/baseline_traindat.rds")
base_test = readRDS("G://users/eileen/ABCD/ABCD_Environmental_Risk/ABCDv5.1/DATA/baseline_testdat.rds")

basedat = rbind(base_train, base_test)

y2_train = readRDS("G://users/eileen/ABCD/ABCD_Environmental_Risk/ABCDv5.1/DATA/y2_traindat.rds")
y2_test = readRDS("G://users/eileen/ABCD/ABCD_Environmental_Risk/ABCDv5.1/DATA/y2_testdat.rds")

y2dat = rbind(y2_train, y2_test)

rm(base_train, base_test, y2_train, y2_test)
```

```{r}
dep_coef_base = read.csv("G://users/eileen/ABCD/ABCD_Environmental_Risk/ABCDv5.1/OUTPUT/baseline_dep_coefs.csv")
int_coef_base = read.csv("G://users/eileen/ABCD/ABCD_Environmental_Risk/ABCDv5.1/OUTPUT/baseline_int_coefs.csv")

coef_base = data.frame(
  predictors = dep_coef_base$X,
  dep_coef = dep_coef_base$x,
  int_coef = int_coef_base$x
)

dep_coef_y2 = read.csv("G://users/eileen/ABCD/ABCD_Environmental_Risk/ABCDv5.1/OUTPUT/y2_dep_coefs.csv")
int_coef_y2 = read.csv("G://users/eileen/ABCD/ABCD_Environmental_Risk/ABCDv5.1/OUTPUT/y2_int_coefs.csv")

coef_y2 = data.frame(
  predictors = dep_coef_y2$X,
  dep_coef = dep_coef_y2$x,
  int_coef = int_coef_y2$x
)

rm(dep_coef_base, dep_coef_y2, int_coef_base, int_coef_y2)
```

## Get environmental scores at baseline and year 2

Pros/cons to using complete cases ABCD data (i.e. no missing) or to continue using imputed datasets for pooled analyses? Would it be an option to collapse the imputed datasets back down into a single one? Could take the mean value for each ppt who has missing data. Similar paper incorporating neuroimaging etc etc uses complete data only. Perhaps I do a sensitivity analysis using just complete data for the ENs and compare. 

For now I've used unimputed:
Baseline complete data only N=7588

```{r envRSbase}
base_cols = coef_base$predictors[-grep(coef_base$predictors, pattern = "_gender")]
basedat_comp = basedat[complete.cases(basedat),] |> select(src_subject_id, base_cols[-1])

nointeract = data.matrix(basedat_comp[,-which(colnames(basedat_comp) %in% rem_cols)])

base_matrix = data.matrix(basedat_comp)

interactmat = nointeract[,-grep("gender", colnames(nointeract))] * nointeract[,grep("gender", colnames(nointeract))]
colnames(interactmat) = paste0(colnames(interactmat), "_gender")

predmat = cbind(basedat$src_subject_id, nointeract, interactmat)
names(predmat)[1] = "src_subject_id"

#multiply by depression coefficients

mult = dep_coef_base[2:nrow(dep_coef_base), 2]
intercept = dep_coef_base[1,2]

depRS = c()
for (n in 1:nrow(predmat)) {
  subj = as.numeric(predmat[n,-1])
  multiply = subj*mult
  depRS = sum(multiply) + intercept
}

#multiply by internalising coefficients

mult = int_coef_base[2:nrow(int_coef_base), 2]
intercept = int_coef_base[1,2]

intRS = c()
for (n in 1:nrow(predmat)) {
  subj = as.numeric(predmat[n,-1])
  multiply = subj*mult
  intRS = sum(multiply) + intercept
basedat_comp = cbind(basedat_comp, intRS, depRS)
```

```{r envRSy2}
rem_cols = c("src_subject_id", "gender_id", "race_ethnicity", "cbcl_internalising", "cbcl_dsm5_depress")

y2_comp = y2dat[complete.cases(y2dat),]
nointeract = data.matrix(y2_comp[,-which(colnames(y2_comp) %in% rem_cols)])

interactmat = nointeract[,-grep("gender", colnames(nointeract))] * nointeract[,grep("gender", colnames(nointeract))]	

colnames(interactmat) = paste0(colnames(interactmat), "_gender")

predmat = cbind(y2_comp$src_subject_id, nointeract, interactmat)
names(predmat)[1] = "src_subject_id"

#multiply by depression coefficients

mult = dep_coef_y2[2:nrow(dep_coef_y2), 2]
intercept = dep_coef_y2[1,2]

depRS = c()
for (n in 1:nrow(predmat)) {
  subj = as.numeric(predmat[n,-1])
  multiply = subj*mult
  depRS = sum(multiply) + intercept
}

#multiply by internalising coefficients

mult = int_coef_y2[2:nrow(int_coef_y2), 2]
intercept = int_coef_y2[1,2]

intRS = c()
for (n in 1:nrow(predmat)) {
  subj = as.numeric(predmat[n,-1])
  multiply = subj*mult
  intRS = sum(multiply) + intercept
}

y2_comp = cbind(y2_comp, intRS, depRS)
```

